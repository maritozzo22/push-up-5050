---
phase: 03.5-smart-notifications
plan: 03
type: execute
wave: 2
depends_on: [03.5-01, 03.5-02]
files_modified:
  - push_up_5050/lib/services/notification_scheduler.dart
  - push_up_5050/lib/screens/home/home_screen.dart
  - push_up_5050/lib/screens/statistics/statistics_screen.dart
  - push_up_5050/lib/main.dart
  - push_up_5050/lib/services/notification_service.dart
autonomous: false

must_haves:
  truths:
    - "Streak at risk notification fires after 2 consecutive days with zero push-ups"
    - "Progress notification fires when within 5 of daily goal AND 50% complete"
    - "Weekly challenge notification fires every Sunday at 8:00 AM"
    - "Tapping notification opens appropriate screen (Home for streak/progress, Statistics for challenge)"
    - "Notifications use personalized time based on user's workout patterns"
  artifacts:
    - path: "push_up_5050/lib/services/notification_scheduler.dart"
      provides: "Smart notification scheduling and condition checking logic"
      exports: ["scheduleAllSmartNotifications", "checkAndScheduleStreakAtRisk", "checkAndScheduleProgress"]
    - path: "push_up_5050/lib/screens/home/home_screen.dart"
      provides: "Integration point for scheduling/triggering notifications on app state changes"
      contains: "scheduleNotificationsIfNeeded"
  key_links:
    - from: "NotificationScheduler"
      to: "NotificationService.scheduleStreakAtRiskNotification"
      via: "Direct method call with localized strings from AppLocalizations"
      pattern: "scheduleStreakAtRiskNotification"
    - from: "NotificationScheduler"
      to: "StorageService for missed days calculation"
      via: "Direct calculation from daily records (no UserStatsProvider dependency)"
      pattern: "loadDailyRecords"
    - from: "NotificationService._onNotificationTap"
      to: "Navigation"
      via: "Deep link to appropriate screen"
      pattern: "onDidReceiveNotificationResponse"
---

<objective>
Create NotificationScheduler and Wire Notification Triggers

Purpose: Build the NotificationScheduler service that checks conditions (streak at risk, progress near goal) and schedules appropriate notifications with localized content. Wire scheduler into app lifecycle and notification tap handling for complete smart notification system.

Output:
- NotificationScheduler service with condition checking and scheduling logic
- NotificationScheduler uses AppLocalizations to provide localized strings to NotificationService
- Notification tap handler with deep link navigation to Home or Statistics
- Provider registration for NotificationScheduler in main.dart
- Trigger calls from HomeScreen and StatisticsScreen on relevant state changes
</objective>

<execution_context>
@C:\Users\olegn\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\olegn\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.5-smart-notifications/*-CONTEXT.md
@.planning/phases/03.5-smart-notifications/*-RESEARCH.md

@push_up_5050/lib/services/notification_service.dart
@push_up_5050/lib/providers/notification_preferences_provider.dart
@push_up_5050/lib/screens/home/home_screen.dart
@push_up_5050/lib/screens/statistics/statistics_screen.dart
@push_up_5050/lib/main.dart
@push_up_5050/lib/repositories/storage_service.dart
</context>

<tasks>

<task type="auto">
  <name>Create NotificationScheduler service with localized content</name>
  <files>push_up_5050/lib/services/notification_scheduler.dart</files>
  <action>
    Create NotificationScheduler class with:

    ```dart
    import 'package:flutter/foundation.dart';
    import 'package:flutter/material.dart';
    import 'package:push_up_5050/l10n/app_localizations.dart';
    import 'package:push_up_5050/services/notification_service.dart';
    import 'package:push_up_5050/providers/notification_preferences_provider.dart';
    import 'package:push_up_5050/repositories/storage_service.dart';

    /// Scheduler for smart notifications based on user behavior.
    ///
    /// Checks conditions and schedules:
    /// - Streak at risk (2+ consecutive missed days)
    /// - Progress encouragement (within 5 of goal, 50%+ complete)
    /// - Weekly challenge (Sunday 8:00 AM, always scheduled)
    class NotificationScheduler {
      final NotificationService _notificationService;
      final NotificationPreferencesProvider _preferencesProvider;
      final StorageService _storage;

      NotificationScheduler({
        required NotificationService notificationService,
        required NotificationPreferencesProvider preferencesProvider,
        required StorageService storage,
      })  : _notificationService = notificationService,
            _preferencesProvider = preferencesProvider,
            _storage = storage;

      /// Schedule all smart notifications based on current state.
      ///
      /// Should be called:
      /// - On app startup (from main.dart)
      /// - After workout completion
      /// - When stats refresh (streak may change)
      Future<void> scheduleAllSmartNotifications(BuildContext context) async {
        await checkAndScheduleStreakAtRisk(context);
        await checkAndScheduleProgress(context);
        await scheduleWeeklyChallenge(context);
      }

      /// Check streak condition and schedule streak at risk notification.
      ///
      /// Conditions:
      /// - consecutiveMissedDays >= 2
      /// - User has NOT worked out today (todayPushups == 0)
      ///
      /// If conditions met, schedule at personalized time.
      /// If conditions not met, cancel existing streak notification.
      Future<void> checkAndScheduleStreakAtRisk(BuildContext context) async {
        final loc = AppLocalizations.of(context)!;

        final records = await _storage.loadDailyRecords();
        final today = DateTime.now();
        final todayKey = _formatDate(today);

        // Check if user worked out today
        final todayRecord = records[todayKey];
        final workedOutToday = todayRecord != null &&
            (todayRecord as Map<String, dynamic>)['totalPushups'] as int > 0;

        if (workedOutToday) {
          // User active today, cancel streak warning
          await _notificationService.cancel(NotificationIds.streakAtRisk);
          debugPrint('NotificationScheduler: User worked out today, streak warning canceled');
          return;
        }

        // Calculate consecutive missed days
        int missedDays = 0;
        DateTime checkDate = today.subtract(const Duration(days: 1));

        for (int i = 0; i < 30; i++) {
          final key = _formatDate(checkDate);
          if (records.containsKey(key)) {
            final recordData = records[key] as Map<String, dynamic>;
            final pushups = recordData['totalPushups'] as int;
            if (pushups > 0) break; // Found activity, stop counting
            missedDays++;
          } else if (i > 0) {
            // No record for past day = missed
            missedDays++;
          }
          checkDate = checkDate.subtract(const Duration(days: 1));
        }

        if (missedDays >= 2) {
          // Schedule streak at risk notification
          final hour = _preferencesProvider.personalizedHour;
          final minute = _preferencesProvider.personalizedMinute;

          // Choose message based on days missed
          final body = missedDays == 3
              ? loc.notificationStreakAtRiskBodyDay3
              : loc.notificationStreakAtRiskBodyDay4(missedDays);

          await _notificationService.scheduleStreakAtRiskNotification(
            title: loc.notificationStreakAtRiskTitle,
            body: body,
            channelName: loc.notificationStreakChannel,
            channelDescription: loc.notificationStreakChannelDesc,
            hour: hour,
            minute: minute,
          );
          debugPrint('NotificationScheduler: Streak at risk scheduled (missed $missedDays days)');
        } else {
          // Not at risk, cancel if exists
          await _notificationService.cancel(NotificationIds.streakAtRisk);
        }
      }

      /// Check progress condition and schedule progress notification.
      ///
      /// Conditions (NOTIF-02 requirement):
      /// - todayPushups >= dailyGoal * 0.5 (50% complete)
      /// - todayPushups <= dailyGoal - 5 (within 5 of goal)
      /// - NOT already at goal
      ///
      /// If conditions met, schedule at personalized time.
      /// Note: Actual condition check happens at scheduled time.
      Future<void> checkAndScheduleProgress(BuildContext context) async {
        final loc = AppLocalizations.of(context)!;

        final dailyGoal = _storage.getDailyGoal();
        final todayRecord = await _storage.getDailyRecord(DateTime.now());
        final todayPushups = todayRecord?.totalPushups ?? 0;

        // Calculate thresholds per NOTIF-02:
        // - 50% threshold: dailyGoal * 0.5
        // - Near goal threshold: dailyGoal - 5
        final halfGoal = (dailyGoal * 0.5).floor();
        final nearGoal = dailyGoal - 5;

        // Only schedule if in the "progress zone" (both conditions must be true)
        if (todayPushups >= halfGoal && todayPushups <= nearGoal) {
          final hour = _preferencesProvider.personalizedHour;
          final minute = _preferencesProvider.personalizedMinute;

          await _notificationService.scheduleProgressNotification(
            title: loc.notificationProgressTitle,
            body: loc.notificationProgressBody,
            channelName: loc.notificationProgressChannel,
            channelDescription: loc.notificationProgressChannelDesc,
            hour: hour,
            minute: minute,
          );
          debugPrint('NotificationScheduler: Progress notification scheduled ($todayPushups pushups, goal: $dailyGoal)');
        } else {
          // Outside progress zone, cancel if exists
          await _notificationService.cancel(NotificationIds.progressEncouragement);
        }
      }

      /// Schedule weekly challenge notification (Sunday 8:00 AM).
      ///
      /// This notification is NOT personalized - always fires Sunday at 8:00 AM.
      /// Should be scheduled once and repeats weekly.
      Future<void> scheduleWeeklyChallenge(BuildContext context) async {
        final loc = AppLocalizations.of(context)!;

        await _notificationService.scheduleWeeklyChallengeNotification(
          title: loc.notificationChallengeTitle,
          body: loc.notificationChallengeBody,
          channelName: loc.notificationChallengeChannel,
          channelDescription: loc.notificationChallengeChannelDesc,
        );
        debugPrint('NotificationScheduler: Weekly challenge notification scheduled');
      }

      String _formatDate(DateTime date) {
        return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
      }
    }
    ```

    Key design decisions:
    - Streak notification: checks consecutive missed days directly from StorageService, cancels if user active today
    - Progress notification: explicitly documents 50% threshold (dailyGoal * 0.5) as per NOTIF-02
    - Weekly challenge: always Sunday 8:00 AM, not personalized
    - All user-facing strings come from AppLocalizations (localized)
    - Each method checks conditions before scheduling
    - Cancels existing notifications when conditions no longer met
    - No dependency on UserStatsProvider for missed days (calculated directly from daily records)

    Pattern: Follow existing service patterns (NotificationService, WidgetUpdateService)
  </action>
  <verify>
    flutter analyze push_up_5050/lib/services/notification_scheduler.dart
  </verify>
  <done>NotificationScheduler created with condition checking, localized content, and proper threshold documentation</done>
</task>

<task type="auto">
  <name>Update NotificationService with deep link handling</name>
  <files>push_up_5050/lib/services/notification_service.dart</files>
  <action>
    Update NotificationService to support deep linking when notifications are tapped:

    1. Add callback parameter to class:
       ```dart
       typedef NotificationTapCallback = void Function(String? payload);

       class NotificationService {
         final FlutterLocalNotificationsPlugin _plugin;
         bool _initialized = false;
         NotificationTapCallback? _onNotificationTapCallback;

         // ... existing code ...
       ```

    2. Add method to register tap callback:
       ```dart
       /// Register callback for notification tap events.
       ///
       /// Called when user taps a notification. Payload contains notification type.
       void setOnNotificationTapCallback(NotificationTapCallback callback) {
         _onNotificationTapCallback = callback;
       }
       ```

    3. Update `_onNotificationTap` method:
       ```dart
       void _onNotificationTap(NotificationResponse response) {
         debugPrint('Notification tapped: ${response.payload}');

         // Notify registered callback
         _onNotificationTapCallback?.call(response.payload);
       }
       ```

    4. Update scheduling methods to include payload:

       In scheduleStreakAtRiskNotification:
       ```dart
       await _plugin.zonedSchedule(
         NotificationIds.streakAtRisk,
         title,
         body,
         scheduledTime,
         platformDetails,
         payload: 'streak_at_risk',  // ADD THIS
         androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
         matchDateTimeComponents: DateTimeComponents.time,
         uiLocalNotificationDateInterpretation: UILocalNotificationDateInterpretation.absoluteTime,
       );
       ```

       In scheduleProgressNotification (add payload: 'progress'):
       In scheduleWeeklyChallengeNotification (add payload: 'weekly_challenge'):

    Pattern: Follow existing notification tap pattern with payload routing
  </action>
  <verify>
    flutter analyze push_up_5050/lib/services/notification_service.dart
  </verify>
  <done>NotificationService updated with deep link handling</done>
</task>

<task type="auto">
  <name>Register providers and wire notification scheduler in main.dart</name>
  <files>push_up_5050/lib/main.dart</files>
  <action>
    Update main.dart to:

    1. Add NotificationScheduler to provider tree:
       ```dart
       // After existing providers...
       ChangeNotifierProvider(
         create: (_) => NotificationPreferencesProvider(
           storage: context.read<StorageService>(),
         ),
       ),
       Provider(
         create: (context) => NotificationScheduler(
           notificationService: context.read<NotificationService>(),
           preferencesProvider: context.read<NotificationPreferencesProvider>(),
           storage: context.read<StorageService>(),
         ),
       ),
       ```

    2. Set up notification tap callback in main app initialization:
       ```dart
       // In MyApp or after providers initialized
       void _setupNotificationTapHandling(BuildContext context) {
         final notificationService = context.read<NotificationService>();
         final navigatorKey = GlobalKey<NavigatorState>();

         notificationService.setOnNotificationTapCallback((payload) {
           // Navigate based on notification type
           switch (payload) {
             case 'streak_at_risk':
             case 'progress':
               navigatorKey.currentState?.pushNamed('/home');
               break;
             case 'weekly_challenge':
               navigatorKey.currentState?.pushNamed('/statistics');
               break;
           }
         });
       }
       ```

       Note: If app uses named routes, use them. If using widget navigation, push widget directly.

    3. Trigger initial notification scheduling on app start:
       ```dart
       // In app initialization or home screen initState
       Future<void> _initializeNotifications(BuildContext context) async {
         final notificationService = context.read<NotificationService>();
         final preferencesProvider = context.read<NotificationPreferencesProvider>();
         final scheduler = context.read<NotificationScheduler>();

         // Initialize notification service
         await notificationService.initialize();

         // Load notification preferences
         await preferencesProvider.loadPreferences();

         // Schedule all smart notifications with context for localization
         await scheduler.scheduleAllSmartNotifications(context);
       }
       ```

    Pattern: Follow existing provider registration and service initialization patterns
  </action>
  <verify>
    flutter analyze push_up_5050/lib/main.dart
  </verify>
  <done>Providers registered and notification scheduler wired in main.dart</done>
</task>

<task type="auto">
  <name>Add notification triggers to HomeScreen</name>
  <files>push_up_5050/lib/screens/home/home_screen.dart</files>
  <action>
    Update HomeScreen to trigger notification scheduling on relevant state changes:

    1. In initState, after loading stats:
       ```dart
       @override
       void initState() {
         super.initState();

         // ... existing code ...

         // Schedule notifications after stats load
         WidgetsBinding.instance.addPostFrameCallback((_) {
           _scheduleNotificationsIfNeeded();
         });
       }

       Future<void> _scheduleNotificationsIfNeeded() async {
         try {
           final scheduler = context.read<NotificationScheduler>();
           await scheduler.scheduleAllSmartNotifications(context);
         } catch (e) {
           debugPrint('HomeScreen: Failed to schedule notifications: $e');
         }
       }
       ```

    2. Also call after workout completion (if HomeScreen has refresh logic):
       ```dart
       // In existing refresh/stats update methods
       await _scheduleNotificationsIfNeeded();
       ```

    This ensures:
    - Notifications are checked when app opens
    - Notifications re-evaluated after stats refresh (streak may have changed)
    - Progress notification scheduled/unscheduled based on current progress

    Pattern: Follow existing post-frame callback pattern for one-time initialization
  </action>
  <verify>
    flutter analyze push_up_5050/lib/screens/home/home_screen.dart
  </verify>
  <done>Notification triggers added to HomeScreen</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete smart notification system with scheduling, condition checking, localized content, and deep link navigation</what-built>
  <how-to-verify>
    1. Run the app on physical Android device (emulator may have notification issues)

    2. Test streak at risk notification:
       - Go to Android Settings > Apps > Push-Up 5050 > Notifications
       - Verify "Streak Reminders" channel exists (localized name based on app locale)
       - Miss 2 days of workouts (simulate by changing system date or waiting)
       - Verify notification appears at personalized time
       - Verify notification text is in correct language (IT/EN based on app settings)

    3. Test progress notification:
       - Complete 50% of daily goal (25+ push-ups if goal is 50)
       - Stay within 5 of goal (25-44 push-ups)
       - Verify notification appears at personalized time
       - Verify notification text is localized

    4. Test weekly challenge notification:
       - Change system date to Sunday before 8:00 AM
       - Wait until 8:00 AM
       - Verify "New weekly challenge available" notification appears
       - Verify notification text is localized

    5. Test deep link navigation:
       - Tap streak notification -> Should open Home screen
       - Tap progress notification -> Should open Home screen
       - Tap challenge notification -> Should open Statistics screen

    6. Test notification channels in Android settings:
       - Go to Settings > Apps > Push-Up 5050 > Notifications
       - Verify 3 channels: Streak Reminders, Progress Reminders, Weekly Challenge
       - Verify channel names are localized
       - Try disabling each channel and verify those notifications stop

    7. Test language switching:
       - Change app language to English
       - Trigger notification scheduling
       - Notifications should show in English
       - Change app language to Italian
       - Notifications should show in Italian
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Run `flutter analyze` - no errors
2. Run `flutter test` - all tests pass
3. NotificationScheduler compiles without errors
4. NotificationScheduler uses AppLocalizations for all user-facing strings
5. NotificationService updated with callback and payload support
6. main.dart registers all new providers
7. HomeScreen triggers notification scheduling
8. checkAndScheduleProgress explicitly documents 50% threshold (dailyGoal * 0.5)
9. NotificationScheduler calculates missed days directly from StorageService (no UserStatsProvider dependency)
10. Manual verification on physical device confirms all notification types work with localized content
</verification>

<success_criteria>
- Streak at risk notification fires after 2+ consecutive missed days
- Progress notification fires when in progress zone (50%+, within 5 of goal) - both thresholds checked
- Weekly challenge notification fires Sunday at 8:00 AM
- Tapping notifications navigates to correct screen
- Notification channels appear in Android system settings with localized names
- All notifications use localized strings from AppLocalizations
- NotificationScheduler calculates conditions directly from StorageService
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-smart-notifications/03.5-03-SUMMARY.md`
</output>
