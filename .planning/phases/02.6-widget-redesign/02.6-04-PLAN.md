---
phase: 02.6-widget-redesign
plan: 04
type: execute
wave: 4
depends_on: [02.6-01, 02.6-02, 02.6-03]
files_modified:
  - push_up_5050/android/app/build.gradle.kts
  - push_up_5050/android/app/src/main/AndroidManifest.xml
  - push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/MidnightWidgetUpdateWorker.kt
  - push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/WidgetUpdateReceiver.kt
autonomous: true
user_setup: []

must_haves:
  truths:
    - "WorkManager scheduled task runs at 00:01 to update widget calendar"
    - "Yesterday's day is marked as missed if no workout was completed"
    - "Widget calendar refreshes to show current week (Monday-Sunday)"
    - "3-day widget shows correct Yesterday-Today-Tomorrow after midnight"
    - "Widget update does not require app to be running"
    - "Battery usage is minimal (WorkManager constraints)"
  artifacts:
    - path: "push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/MidnightWidgetUpdateWorker.kt"
      provides: "WorkManager worker for midnight widget updates"
      min_lines: 80
    - path: "push_up_5050/android/app/build.gradle.kts"
      provides: "WorkManager dependency"
      modifies: "dependencies block"
    - path: "push_up_5050/android/app/src/main/AndroidManifest.xml"
      provides: "BOOT_COMPLETED receiver for persistent scheduling"
      modifies: "application block"
  key_links:
    - from: "MidnightWidgetUpdateWorker"
      to: "HomeWidgetPlugin"
      via: "updateWidget() call"
      pattern: "HomeWidgetPlugin\\.updateWidget"
    - from: "WidgetUpdateReceiver"
      to: "MidnightWidgetUpdateWorker"
      via: "WorkManager enqueue request"
      pattern: "WorkManager\\.getInstance\\(\\)\\.enqueue"
    - from: "AndroidManifest"
      to: "WidgetUpdateReceiver"
      via: "BOOT_COMPLETED intent-filter"
      pattern: "RECEIVE_BOOT_COMPLETED"
---

<objective>
Implement Midnight Widget Update for Calendar Refresh

Purpose: Schedule daily midnight task to update widget calendar, marking missed days and refreshing week view

Output: WorkManager-based midnight update that runs without app interaction
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.6-widget-redesign/02.6-CONTEXT.md
@.planning/phases/02.6-widget-redesign/02.6-01-SUMMARY.md
@.planning/phases/02.6-widget-redesign/02.6-02-SUMMARY.md
@.planning/phases/02.6-widget-redesign/02.6-03-SUMMARY.md
@push_up_5050/android/app/build.gradle.kts
@push_up_5050/android/app/src/main/AndroidManifest.xml
@push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/PushupWidgetQuickStartProvider.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WorkManager dependency to build.gradle.kts</name>
  <files>push_up_5050/android/app/build.gradle.kts</files>
  <action>
    Add WorkManager dependency to Android build.gradle.kts:

    1. In dependencies block, add:
       ```kotlin
       implementation("androidx.work:work-runtime-ktx:2.9.0")
       ```

    2. Sync Gradle (automatically on next build)

    WorkManager is part of Android Jetpack and provides:
    - Battery-efficient background task scheduling
    - Automatic retry with backoff
    - Constraints (device idle, charging, network)
    - Boot-persistent scheduling

    Use version 2.9.0 for compatibility with Flutter's Android Gradle Plugin.
  </action>
  <verify>
    ./gradlew build dependencies --quiet
    WorkManager dependency resolved successfully
  </verify>
  <done>
    WorkManager dependency added to Android project
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MidnightWidgetUpdateWorker</name>
  <files>push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/MidnightWidgetUpdateWorker.kt</files>
  <action>
    Create MidnightWidgetUpdateWorker class in widget package:

    ```kotlin
    package com.pushup5050.push_up_5050.widget

    import android.content.Context
    import androidx.work.CoroutineWorker
    import androidx.work.WorkerParameters
    import es.antonborri.home_widget.HomeWidgetPlugin
    import android.appwidget.AppWidgetManager
    import com.pushup5050.push_up_5050.R

    class MidnightWidgetUpdateWorker(
        context: Context,
        params: WorkerParameters
    ) : CoroutineWorker(context, params) {

        override suspend fun doWork(): Result {
            return try {
                // Trigger widget refresh - calendar will re-render
                // with updated day statuses (yesterday may now be missed)
                HomeWidgetPlugin.updateWidget(
                    applicationContext,
                    "PushupWidgetQuickStartProvider"
                )
                HomeWidgetPlugin.updateWidget(
                    applicationContext,
                    "PushupWidgetSmallProvider"
                )

                Result.success()
            } catch (e: Exception) {
                // Retry on failure
                Result.retry()
            }
        }

        companion object {
            const val WORK_NAME = "midnight_widget_update"
        }
    }
    ```

    The worker simply triggers widget refresh. The widget providers themselves
    read current date and calculate statuses (completed/missed/pending) based on
    stored data. When the calendar refreshes after midnight, "today" becomes
    "yesterday" and will show as missed if no workout record exists.
  </action>
  <verify>
    flutter build apk --debug
    APK builds without Kotlin errors
  </verify>
  <done>
    MidnightWidgetUpdateWorker created for background widget updates
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WidgetUpdateReceiver for boot and scheduling</name>
  <files>push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/widget/WidgetUpdateReceiver.kt</files>
  <action>
    Create BroadcastReceiver for boot-complete and app-based scheduling:

    ```kotlin
    package com.pushup5050.push_up_5050.widget

    import android.content.BroadcastReceiver
    import android.content.Context
    import android.content.Intent
    import androidx.work.Constraints
    import androidx.work.ExistingPeriodicWorkPolicy
    import androidx.work.PeriodicWorkRequestBuilder
    import androidx.work.WorkManager
    import java.util.concurrent.TimeUnit

    class WidgetUpdateReceiver : BroadcastReceiver() {

        override fun onReceive(context: Context, intent: Intent) {
            if (intent.action == Intent.ACTION_BOOT_COMPLETED ||
                intent.action == "com.pushup5050.WIDGET_UPDATE_SCHEDULE") {
                scheduleMidnightUpdate(context)
            }
        }

        companion object {
            fun scheduleMidnightUpdate(context: Context) {
                // Calculate time until 00:01
                val now = System.currentTimeMillis()
                val calendar = java.util.Calendar.getInstance().apply {
                    set(java.util.Calendar.HOUR_OF_DAY, 0)
                    set(java.util.Calendar.MINUTE, 1)
                    set(java.util.Calendar.SECOND, 0)
                    add(java.util.Calendar.DAY_OF_MONTH, 1) // Tomorrow
                }

                val delayMillis = calendar.timeInMillis - now
                val initialDelay = if (delayMillis > 0) delayMillis else TimeUnit.DAYS.toMillis(1)

                val constraints = Constraints.Builder()
                    .setRequiresDeviceIdle(false)
                    .setRequiresCharging(false)
                    .build()

                val workRequest = PeriodicWorkRequestBuilder<MidnightWidgetUpdateWorker>(
                    24, TimeUnit.HOURS
                )
                    .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
                    .setConstraints(constraints)
                    .build()

                WorkManager.getInstance(context).enqueueUniquePeriodicWork(
                    MidnightWidgetUpdateWorker.WORK_NAME,
                    ExistingPeriodicWorkPolicy.KEEP,
                    workRequest
                )
            }
        }
    }
    ```

    Schedules WorkManager task to run at 00:01 daily.
    Re-schedules after device boot.
  </action>
  <verify>
    flutter build apk --debug
    APK builds without errors
  </verify>
  <done>
    WidgetUpdateReceiver schedules midnight update via WorkManager
  </done>
</task>

<task type="auto">
  <name>Task 4: Update AndroidManifest with receiver permissions</name>
  <files>push_up_5050/android/app/src/main/AndroidManifest.xml</files>
  <action>
    Update AndroidManifest.xml to register WidgetUpdateReceiver:

    1. Add receiver inside &lt;application&gt; block:
       ```xml
       <!-- Widget Midnight Update Receiver -->
       <receiver
           android:name=".widget.WidgetUpdateReceiver"
           android:enabled="true"
           android:exported="false">
           <intent-filter>
               <action android:name="android.intent.action.BOOT_COMPLETED" />
           </intent-filter>
       </receiver>
       ```

    2. Verify RECEIVE_BOOT_COMPLETED permission exists (should already be present at top of manifest)

    The receiver re-schedules the midnight update after device reboot.
    Without this, widgets would stop refreshing at midnight until the app is launched again.

    exported="false" prevents other apps from triggering our receiver.
  </action>
  <verify>
    flutter build apk --debug
    APK builds, manifest valid
  </verify>
  <done>
    WidgetUpdateReceiver registered in AndroidManifest with boot permission
  </done>
</task>

<task type="auto">
  <name>Task 5: Schedule midnight update from Flutter side</name>
  <files>
    push_up_5050/android/app/src/main/kotlin/com/pushup5050/push_up_5050/MainActivity.kt,
    push_up_5050/lib/services/widget_update_service.dart
  </files>
  <action>
    Add MethodChannel endpoint to trigger midnight update scheduling from Flutter:

    **MainActivity.kt**:
    1. Add MethodChannel handler:
       ```kotlin
       // In configureFlutterEngine()
       MethodChannel(flutterEngine.dartExecutor.binaryMessenger, "com.pushup5050/widget")
           .setMethodCallHandler { call, result ->
               when (call.method) {
                   "scheduleMidnightUpdate" -> {
                       WidgetUpdateReceiver.scheduleMidnightUpdate(this)
                       result.success(true)
                   }
                   else -> result.notImplemented()
               }
           }
       ```

    **WidgetUpdateService.dart**:
    1. Add platform channel constant:
       ```dart
       static const _widgetChannel = MethodChannel('com.pushup5050/widget');
       ```

    2. Add method to schedule midnight update:
       ```dart
       Future<void> scheduleMidnightUpdate() async {
         if (!_isAvailable) return;
         try {
           await _widgetChannel.invokeMethod('scheduleMidnightUpdate');
         } catch (e) {
           developer.log('Failed to schedule midnight update: $e', name: 'WidgetUpdateService');
         }
       }
       ```

    3. Call scheduleMidnightUpdate() in initialize() method

    This ensures the midnight update is scheduled when the app first launches.
    WorkManager persists the schedule across app restarts and device reboots.
  </action>
  <verify>
    flutter build apk --debug
    APK builds, no MethodChannel errors
  </verify>
  <done>
    Flutter app schedules midnight update on first launch
  </done>
</task>

<task type="auto">
  <name>Task 6: Add tests for midnight update scheduling</name>
  <files>push_up_5050/test/services/widget_update_service_test.dart</files>
  <action>
    Add tests for midnight update functionality:

    1. test_scheduleMidnightUpdate_callsPlatformChannel:
       - Mock MethodChannel
       - Verify scheduleMidnightUpdate() invokes correct method

    2. test_scheduleMidnightUpdate_handlesUnavailableGracefully:
       - Set _isAvailable = false
       - Verify no exception thrown

    3. test_initialize_schedulesMidnightUpdate:
       - Verify initialize() calls scheduleMidnightUpdate()

    Use existing mock patterns. MethodChannel mocking requires platform channel setup.
  </action>
  <verify>
    flutter test push_up_5050/test/services/widget_update_service_test.dart
    New tests pass
  </verify>
  <done>
    Midnight update scheduling verified with tests
  </done>
</task>

</tasks>

<verification>
1. WorkManager dependency added to build.gradle.kts
2. MidnightWidgetUpdateWorker created and builds without errors
3. WidgetUpdateReceiver schedules daily 00:01 task
4. AndroidManifest registers receiver with BOOT_COMPLETED permission
5. Flutter MethodChannel triggers scheduling from app
6. Tests verify scheduling logic
7. Battery constraints are minimal (no charging/idle requirements)
</verification>

<success_criteria>
- Midnight update scheduled via WorkManager
- Widget calendar refreshes at 00:01 daily
- Schedule persists across device reboot
- Flutter app initializes schedule on first launch
- Tests verify scheduling functionality
- Ready for end-to-end verification in next plan
</success_criteria>

<output>
After completion, create `.planning/phases/02.6-widget-redesign/02.6-04-SUMMARY.md`
</output>
