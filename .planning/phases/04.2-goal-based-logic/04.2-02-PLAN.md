---
phase: 04.2-goal-based-logic
plan: 02
type: execute
wave: 2
depends_on: ["04.2-01"]
files_modified:
  - push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart
  - push_up_5050/lib/providers/active_workout_provider.dart
  - push_up_5050/lib/services/audio_service.dart
autonomous: true

must_haves:
  truths:
    - "Workout auto-completes (ends) after recovery when goal is reached"
    - "Final series completes BEFORE recovery timer starts (goal check happens after series, not mid-series)"
    - "Recovery timer checks goalReached when recovery completes, then ends workout"
    - "Navigation goes to Home screen after goal completion (not results screen)"
    - "Completion sound plays when goal is reached"
  artifacts:
    - path: "push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart"
      provides: "Auto-completion flow in recovery timer callback"
      contains: "_handleGoalCompletion"
    - path: "push_up_5050/lib/providers/active_workout_provider.dart"
      provides: "endWorkout() method for terminating session"
      exports: ["endWorkout"]
    - path: "push_up_5050/lib/services/audio_service.dart"
      provides: "Goal achievement sound"
      exports: ["playGoalAchieved"]
  key_links:
    - from: "WorkoutExecutionScreen._onSeriesComplete()"
      to: "ActiveWorkoutProvider.session.goalReached"
      via: "check BEFORE starting recovery timer"
      pattern: "session\.goalReached.*_startRecoveryTimer"
    - from: "WorkoutExecutionScreen._startRecoveryTimer()"
      to: "_handleGoalCompletion()"
      via: "check after recovery completes"
      pattern: "goalReached.*true.*_handleGoalCompletion"
    - from: "WorkoutExecutionScreen"
      to: "Home screen"
      via: "Navigator.pop() instead of results screen"
      pattern: "Navigator\.pop\(context\)"
---

<objective>
Auto-Complete Workout at Goal Reached

Purpose: End workout session and return to Home screen when daily goal is reached, after completing the current series and its recovery period
Output: Modified recovery timer flow with goal completion handling
</objective>

<execution_context>
@C:\Users\olegn\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\olegn\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.2-goal-based-logic/04.2-CONTEXT.md
@.planning/phases/04.2-goal-based-logic/04.2-RESEARCH.md

# Prior plan for dependency
@.planning/phases/04.2-goal-based-logic/04.2-01-SUMMARY.md

# Key implementation files
@C:\Script\Android-Apps\Push-up flutter Nuovo test\push_up_5050\lib\screens\workout_execution\workout_execution_screen.dart
@C:\Script\Android-Apps\Push-up flutter Nuovo test\push_up_5050\lib\providers\active_workout_provider.dart
@C:\Script\Android-Apps\Push-up flutter Nuovo test\push_up_5050\lib\services\audio_service.dart
@C:\Script\Android-Apps\Push-up flutter Nuovo test\push_up_5050\lib\models\workout_session.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add goal achievement sound to AudioService</name>
  <files>push_up_5050/lib/services/audio_service.dart</files>
  <action>
Add a new method `playGoalAchieved()` to AudioService for playing the goal completion sound.

First, read the existing AudioService to understand the pattern for playing sounds.

Add the method following the existing pattern (likely similar to playBeep()):
```dart
/// Play sound when daily goal is achieved.
void playGoalAchieved() {
  // Use a distinct, celebratory sound for goal completion
  // Could be a chime, success sound, or upbeat tone
  _playSound('goal_achieved');
}
```

If the service uses AssetPlayer or similar, add the sound asset reference:
```dart
static const String _goalAchievedSound = 'assets/sounds/goal_achieved.mp3';
```

Implementation notes:
- If goal_achieved.mp3 doesn't exist, reuse an existing positive sound (like level_up or achievement)
- Keep sound duration brief (1-2 seconds max)
- Ensure sound is distinctive from regular beep
</action>
  <verify>
grep -n "playGoalAchieved" push_up_5050/lib/services/audio_service.dart
</verify>
  <done>
AudioService has playGoalAchieved() method that:
- Plays a celebratory sound for goal completion
- Uses existing sound playback infrastructure
- Is distinct from regular workout sounds
</done>
</task>

<task type="auto">
  <name>Task 2: Add goal completion handler stub to WorkoutExecutionScreen</name>
  <files>push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart</files>
  <action>
Add a new private method `_handleGoalCompletion()` stub that will be called when goal is reached.

```dart
Future<void> _handleGoalCompletion(
  ActiveWorkoutProvider provider,
  BuildContext context,
) async {
  // Prevent double-completion
  if (_isCompleting) return;
  _isCompleting = true;

  // End workout (saves session, clears active session)
  await provider.endWorkout();

  // Play goal achievement sound
  final settings = context.read<AppSettingsService>();
  final audio = context.read<AudioService>();
  if (settings.soundsEnabled && settings.goalSoundEnabled) {
    audio.playGoalAchieved();
  }

  // Navigate back to Home (not results screen)
  if (mounted) {
    Navigator.pop(context);
  }
}
```

Also add the state variable at the top of _WorkoutExecutionScreenState class:
```dart
bool _isCompleting = false;
```

Add it after the existing `bool _showCelebration = false;` line.

Add the method stub after `_handleEndWorkout()` (around line 241).
</action>
  <verify>
grep -n "_handleGoalCompletion" push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart
grep -n "_isCompleting" push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart
</verify>
  <done>
_handleGoalCompletion() stub exists with:
- Double-completion prevention via _isCompleting flag
- endWorkout() call to save session
- Completion sound playback (calls AudioService.playGoalAchieved())
- Navigation to Home screen
</done>
</task>

<task type="auto">
  <name>Task 3: Check goal completion before starting recovery (ensures series finishes first)</name>
  <files>push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart</files>
  <action>
Modify the `_onSeriesComplete()` method to check for goal completion BEFORE starting the recovery timer.

This ensures the final series completes fully (all reps counted) before we check goal status.

Find the existing _onSeriesComplete() method (called when repsInCurrentSeries >= currentSeries).

Current flow should be:
1. User completes all reps in current series
2. _onSeriesComplete() is called
3. Recovery timer starts

Add goal check BEFORE step 3:

```dart
void _onSeriesComplete() {
  final provider = context.read<ActiveWorkoutProvider>();

  // Check if goal was just reached BEFORE starting recovery
  if (provider.session?.goalReached == true) {
    // Skip recovery, end workout immediately
    _handleGoalCompletion(provider, context);
    return;
  }

  // Normal flow: start recovery timer
  _startRecoveryTimer();
}
```

The critical behavior: goalReached check happens AFTER series completes but BEFORE recovery starts.

Verification: Ensure the check uses `provider.session?.goalReached` which was set during countRep().
</action>
  <verify>
grep -B 5 -A 10 "goalReached.*true" push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart | grep -A 10 "_onSeriesComplete"
</verify>
  <done>
_onSeriesComplete() checks goalReached flag:
- Check happens AFTER series is complete (all reps counted)
- Check happens BEFORE recovery timer starts
- When goal reached: calls _handleGoalCompletion(), skips recovery
- When goal not reached: starts recovery timer normally
</done>
</task>

<task type="auto">
  <name>Task 4: Modify recovery timer to also check goal completion (defensive check)</name>
  <files>push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart</files>
  <action>
Modify the `_startRecoveryTimer()` method to check for goal completion after recovery finishes as a defensive check.

This handles the edge case where goal is reached mid-series but recovery was already started.

Current code (around line 56-73) does:
```dart
if (complete) {
  timer.cancel();
  // Play beep
  // Auto-advance to next series
  provider.advanceToNextSeries();
}
```

Change to:
```dart
if (complete) {
  timer.cancel();

  // Play beep sound when recovery ends (if enabled)
  final settings = context.read<AppSettingsService>();
  final audio = context.read<AudioService>();
  if (settings.soundsEnabled && settings.beepEnabled) {
    audio.playBeep();
  }

  // Check if goal was reached - if so, end workout instead of advancing
  if (provider.session?.goalReached == true) {
    await _handleGoalCompletion(provider, context);
  } else {
    // Auto-advance to next series when recovery is complete
    provider.advanceToNextSeries();
  }
}
```

This provides a secondary check at recovery completion.
</action>
  <verify>
grep -B 5 -A 15 "_startRecoveryTimer" push_up_5050/lib/screens/workout_execution/workout_execution_screen.dart | grep "goalReached"
</verify>
  <done>
Recovery timer callback has defensive goalReached check:
- Primary check in _onSeriesComplete() (before recovery)
- Secondary check in recovery timer callback (after recovery)
- Both call _handleGoalCompletion() when goal reached
- Beep still plays in both cases
</done>
</task>

<task type="auto">
  <name>Task 5: Add isGoalReached getter to ActiveWorkoutProvider</name>
  <files>push_up_5050/lib/providers/active_workout_provider.dart</files>
  <action>
Add a public getter to expose the goalReached state from the session.

The WorkoutSession model already has `goalReached` field. Add a convenience getter:

```dart
/// Whether the daily goal has been reached in this session.
///
/// Returns the session's goalReached flag, or false if no session.
bool get isGoalReached => _session?.goalReached ?? false;
```

Add this getter after the `sessionPoints` getter (around line 72).

This allows the UI to check goal status without accessing session directly.
</action>
  <verify>
grep -n "isGoalReached" push_up_5050/lib/providers/active_workout_provider.dart
</verify>
  <done>
ActiveWorkoutProvider exposes isGoalReached getter:
- Returns session.goalReached if session exists
- Returns false if no session
- Provides clean API for UI goal checking
</done>
</task>

</tasks>

<verification>
1. Review WorkoutExecutionScreen to verify _handleGoalCompletion() exists
2. Verify _onSeriesComplete() checks goalReached BEFORE starting recovery
3. Verify recovery timer has defensive goalReached check
4. Verify navigation goes to Home (Navigator.pop) not results
5. Verify AudioService.playGoalAchieved() method exists
6. Run: flutter analyze lib/screens/workout_execution/workout_execution_screen.dart
7. Run: flutter test test/screens/workout_execution/ 2>&1 || echo "Tests may need to be updated"
</verification>

<success_criteria>
1. Final series completes fully before goal check happens
2. Goal check happens in _onSeriesComplete() before recovery starts
3. Recovery timer has defensive goal check at completion
4. Workout ends (endWorkout) when goal reached
5. Navigation returns to Home screen, not results screen
6. Completion sound plays before navigation
7. Double-completion prevented by _isCompleting flag
</success_criteria>

<output>
After completion, create `.planning/phases/04.2-goal-based-logic/04.2-02-SUMMARY.md`
</output>
