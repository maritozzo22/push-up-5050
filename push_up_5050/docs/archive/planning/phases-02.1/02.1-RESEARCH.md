# Phase 2.1: Foundation & Setup - Research

**Researched:** 2026-01-21
**Domain:** Flutter Android home screen widgets with home_widget plugin
**Confidence:** HIGH

## Summary

Phase 2.1 involves setting up the Android widget infrastructure for the Push-Up 5050 Flutter app. Research shows that the **home_widget plugin (^0.5.0)** is the standard, lightweight solution for Flutter apps that need home screen widgets. The plugin provides a bridge between Flutter Dart code and native Android/iOS widget implementations, enabling data synchronization without requiring widgets to be written in Flutter.

Key finding: **Most of the foundation work is already complete** in this project. The Android manifest has widget receivers registered, the WidgetData model exists with JSON serialization, WidgetUpdateService is implemented, and basic tests are in place. However, the background update mechanism is a stub (placeholder) and needs proper implementation.

**Critical insight:** For widget background updates, **WorkManager is NOT strictly required**. Android's native `android:updatePeriodMillis` attribute (minimum 30 minutes) in the widget XML configuration handles periodic updates automatically. WorkManager is only needed if you require:
- Updates more frequent than 30 minutes
- Guaranteed execution regardless of battery optimizations
- Complex background tasks beyond simple data refresh

For this app's use case (updating push-up stats every 30 minutes is sufficient), the native approach is simpler and more reliable.

**Primary recommendation:** Use the existing home_widget + native Android updatePeriodMillis approach. Only add WorkManager if future requirements demand sub-30-minute updates or guaranteed background execution.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| home_widget | ^0.5.0 | Flutter plugin for Android/iOS home screen widgets | Provides unified interface for sending data to native widgets, update triggers, and interactive widgets. The de facto standard for Flutter widget development. |
| dart:convert | Built-in | JSON encoding/decoding | No external dependency needed for simple models. Flutter's built-in JSON library is sufficient for widget data serialization. |
| shared_preferences | ^2.2.2 (already in project) | Local data persistence | Required by home_widget for data storage between app and widget. Already in project. |

### Supporting (Optional)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| workmanager | ^0.5.0 (if needed) | Background task scheduling | **ONLY if** you need updates <30 minutes or guaranteed execution. Not needed for basic widgets. |
| json_serializable | ^6.7.0 (if needed) | Code generation for JSON serialization | Use when model complexity grows. **NOT needed** for current WidgetData model which uses simple manual serialization. |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| home_widget | Platform-specific native code (Kotlin/Swift only) | Lose Flutter integration, duplicate data layer code, no unified API |
| Manual dart:convert | json_serializable code generation | Adds build complexity for simple models. Only use when models have many fields or nested structures |
| Native updatePeriodMillis | WorkManager for updates | WorkManager adds complexity and 1MB+ APK size. Native approach is simpler for 30-min+ updates |

**Installation:**
```bash
# Core dependencies (already present in pubspec.yaml)
flutter pub get

# Optional - ONLY add if WorkManager is needed
flutter pub add workmanager
```

## Architecture Patterns

### Recommended Project Structure
```
lib/
├── models/
│   └── widget_data.dart          # ✅ EXISTS - Widget data model with JSON serialization
├── services/
│   └── widget_update_service.dart # ✅ EXISTS - Service for updating widgets
└── core/
    ├── constants/
    │   ├── app_colors.dart        # Widget colors (orange: #FF6B00, dark: #121212)
    │   └── app_strings.dart       # Widget strings
    └── utils/
        └── calculator.dart        # ✅ EXISTS - Formulas for kcal, points, progress

android/
├── app/src/main/
│   ├── AndroidManifest.xml        # ✅ EXISTS - Widget receivers registered
│   ├── kotlin/.../widget/
│   │   ├── PushupWidgetStatsProvider.kt      # ✅ EXISTS - Widget 1 provider
│   │   ├── PushupWidgetCalendarProvider.kt   # ✅ EXISTS - Widget 2 provider
│   │   └── PushupWidgetQuickStartProvider.kt # ✅ EXISTS - Widget 3 provider
│   └── res/
│       ├── xml/
│       │   ├── pushup_widget_stats_info.xml      # ✅ EXISTS - Config (30-min updates)
│       │   ├── pushup_widget_calendar_info.xml   # ✅ EXISTS - Config
│       │   └── pushup_widget_quick_start_info.xml # ✅ EXISTS - Config
│       └── layout/
│           ├── pushup_widget_stats.xml      # ✅ EXISTS - Widget 1 layout
│           ├── pushup_widget_calendar.xml   # ✅ EXISTS - Widget 2 layout
│           └── pushup_widget_quick_start.xml # ✅ EXISTS - Widget 3 layout

test/
├── models/
│   └── widget_data_test.dart      # ✅ EXISTS - Widget data serialization tests
└── services/
    └── widget_update_service_test.dart # ✅ EXISTS - Service tests (if present)
```

### Pattern 1: Widget Data Communication (home_widget)

**What:** Two-way data flow between Flutter app and Android widgets using SharedPreferences bridge.

**When to use:** All home screen widget implementations with home_widget plugin.

**Data Flow:**
1. **App → Widget:** `HomeWidget.saveWidgetData()` stores data in SharedPreferences
2. **Trigger update:** `HomeWidget.updateWidget()` notifies Android to refresh widget
3. **Widget reads:** Android widget provider reads data from SharedPreferences
4. **Widget displays:** Provider updates RemoteViews with fresh data

**Example:**
```dart
// Source: https://pub.dev/packages/home_widget

// Save data from Flutter
await HomeWidget.saveWidgetData<String>('group_id', 'key', 'value');

// Trigger widget update
await HomeWidget.updateWidget('widget_name');

// Android side (Kotlin) - reads the data
val prefs = context.getSharedPreferences("group_id", Context.MODE_PRIVATE)
val value = prefs.getString("key", "default")
```

**Why this pattern:** Widgets run in a separate process and cannot access app memory directly. SharedPreferences is the only reliable shared storage mechanism that works across processes.

### Pattern 2: WidgetData JSON Serialization

**What:** Manual JSON serialization using `dart:convert` for simple, flat data models.

**When to use:** Models with <10 fields, no complex nesting, straightforward type conversions.

**Example:**
```dart
// Source: https://docs.flutter.dev/data-and-backend/serialization/json

class WidgetData {
  final int todayPushups;
  final DateTime? lastWorkoutDate;

  // Serialize to JSON
  Map<String, dynamic> toJson() {
    return {
      'todayPushups': todayPushups,
      'lastWorkoutDate': lastWorkoutDate != null
          ? '${lastWorkoutDate!.year}-${lastWorkoutDate!.month.toString().padLeft(2, '0')}-${lastWorkoutDate!.day.toString().padLeft(2, '0')}'
          : null,
    };
  }

  // Deserialize from JSON
  factory WidgetData.fromJson(Map<String, dynamic> json) {
    return WidgetData(
      todayPushups: json['todayPushups'] as int? ?? 0,
      lastWorkoutDate: json['lastWorkoutDate'] != null
          ? DateTime.parse(json['lastWorkoutDate'] as String)
          : null,
    );
  }

  // Convenience methods
  String toJsonString() => jsonEncode(toJson());
  static WidgetData fromJsonString(String jsonString) =>
      WidgetData.fromJson(jsonDecode(jsonString) as Map<String, dynamic>);
}
```

**Why manual serialization:**
- No code generation step (faster builds)
- Full control over date formatting (YYYY-MM-DD for widget compatibility)
- Easier to debug (no generated .g.dart files)
- Sufficient for simple widget data models

### Pattern 3: Background Widget Updates (Native Approach)

**What:** Use Android's built-in `android:updatePeriodMillis` for periodic widget updates.

**When to use:** Updates ≥30 minutes are acceptable, simple data refresh needed.

**Example (XML configuration):**
```xml
<!-- Source: android/app/src/main/res/xml/pushup_widget_stats_info.xml -->
<appwidget-provider
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:minWidth="250dp"
    android:minHeight="110dp"
    android:updatePeriodMillis="1800000"  <!-- 30 minutes (minimum allowed) -->
    android:initialLayout="@layout/pushup_widget_stats"
    android:resizeMode="horizontal|vertical"
    android:widgetCategory="home_screen">
</appwidget-provider>
```

**How it works:**
1. Android system automatically calls `onUpdate()` every 30 minutes
2. Widget provider reads latest data from SharedPreferences
3. Provider updates RemoteViews with fresh data
4. No Flutter/Dart code execution required

**Why native approach:**
- Zero additional dependencies (no WorkManager package)
- Battery-optimized (system-managed updates)
- Reliable (system handles doze mode, battery saver)
- Simple (no background task registration)

### Pattern 4: Widget Service Integration

**What:** Centralized service for updating all widgets from app state changes.

**When to use:** Multiple widget types, same data source, coordinated updates.

**Example:**
```dart
// Source: lib/services/widget_update_service.dart

class WidgetUpdateService {
  Future<bool> updateAllWidgets(WidgetData data) async {
    // Save data once for all widgets
    await _saveWidgetData(data);

    // Update all 3 widget types in parallel
    final results = await Future.wait([
      updateWidget1(data),
      updateWidget2(data),
      updateWidget3(data),
    ], eagerError: false);

    // Return true if at least one succeeded
    return results.any((success) => success);
  }

  Future<bool> updateWidget1(WidgetData data) async {
    try {
      await HomeWidget.saveWidgetData<String>(
        'group_id', 'key', data.toJsonString());
      await HomeWidget.updateWidget('widget_id');
      return true;
    } catch (e) {
      return false; // Graceful degradation
    }
  }
}
```

**Why service pattern:**
- Encapsulates home_widget API calls
- Handles errors gracefully (widgets are optional)
- Enables batch updates across all widget types
- Testable (mockable interface)

### Anti-Patterns to Avoid

- **Storing complex objects directly in SharedPreferences:** Always serialize to JSON first. SharedPreferences only supports primitive types.
- **Updating widgets on every data change:** Debounce or throttle updates. Excessive updates drain battery.
- **Assuming widgets are always available:** Platform may not support widgets (Windows). Use graceful degradation.
- **Using json_serializable for simple models:** Overkill for <10 fields. Manual serialization is clearer and faster.
- **Hardcoding widget IDs in multiple places:** Centralize in constants or service class.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| SharedPreferences bridge between Flutter and native | Custom method channel | home_widget plugin | Handles platform differences, error cases, and type conversions |
| JSON serialization for widget data | Manual string concatenation | dart:convert (jsonEncode/jsonDecode) | Type-safe, handles escaping, standard library |
| Periodic background updates | Custom AlarmManager + BroadcastReceiver | android:updatePeriodMillis in XML | System-managed, battery-optimized, doze-mode aware |
| Widget data storage | Custom file I/O | SharedPreferences (via home_widget) | Cross-process safe, handles concurrency, simple API |
| Date serialization | Custom formatting | ISO 8601 or YYYY-MM-DD strings | Standard format, timezone-safe, parseable on both sides |

**Key insight:** Android widgets run in a separate process from the main app. Custom inter-process communication (IPC) mechanisms are complex and error-prone. SharedPreferences is the ONLY reliable, built-in data sharing mechanism. Don't reinvent this wheel.

## Common Pitfalls

### Pitfall 1: Widget Data Not Updating

**What goes wrong:** Widgets show stale data even after app updates.

**Why it happens:**
- Forgetting to call `HomeWidget.updateWidget()` after saving data
- Updating wrong widget ID (typo in identifier)
- Widget provider not reading from correct SharedPreferences group

**How to avoid:**
1. Always call `updateWidget()` IMMEDIATELY after `saveWidgetData()`
2. Use constants for widget IDs (avoid typos)
3. Verify SharedPreferences group name matches between Dart and Kotlin
4. Test by: Change data → Save → Trigger update → Verify widget refresh

**Warning signs:** Widget shows old numbers, app data doesn't match widget, updates only work after phone restart.

### Pitfall 2: Date Serialization Failures

**What goes wrong:** DateTime parsing throws FormatException or timezone shifts.

**Why it happens:**
- Using DateTime.toIso8601String() includes time/timezone (too complex)
- Assuming device timezone when parsing dates
- Not handling null dates consistently

**How to avoid:**
```dart
// ✓ CORRECT: Simple YYYY-MM-DD format (no timezone)
'lastWorkoutDate': date != null
    ? '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}'
    : null

// ✗ WRONG: ISO 8601 includes time and timezone
'lastWorkoutDate': date?.toIso8601String()

// Parse safely
DateTime? parseDate(String? dateString) {
  if (dateString == null || dateString.isEmpty) return null;
  final parts = dateString.split('-');
  return DateTime(int.parse(parts[0]), int.parse(parts[1]), int.parse(parts[2]));
}
```

**Warning signs:** FormatException on app launch, dates show wrong day, null pointer exceptions in widget provider.

### Pitfall 3: Update Frequency Too Low

**What goes wrong:** Widgets update too slowly (hours between updates).

**Why it happens:**
- Setting `updatePeriodMillis` < 30 minutes (system ignores it)
- Relying only on manual updates (user closes app, widget never refreshes)
- Battery optimization killing background tasks

**How to avoid:**
```xml
<!-- ✓ CORRECT: 30 minutes = 1800000 ms (minimum allowed) -->
android:updatePeriodMillis="1800000"

<!-- ✗ WRONG: System will ignore, default to 30 min anyway -->
android:updatePeriodMillis="300000"  <!-- 5 minutes - won't work! -->
```

**Update strategies:**
1. **Hybrid approach:** Use 30-min periodic + trigger updates on app state changes
2. **Broadcast listeners:** Update on system events (boot completed, time zone changed)
3. **Manual refresh:** Add refresh button in widget layout (if needed)

**Warning signs:** Widget shows stale data for hours, updates only work when app is open, users complain about lag.

### Pitfall 4: Testing JSON Serialization

**What goes wrong:** Serialization tests pass but production crashes.

**Why it happens:**
- Tests use ideal data (no nulls, no missing fields)
- Not testing round-trip (serialize → deserialize → compare)
- Ignoring type casting errors (e.g., String instead of int)

**How to avoid:**
```dart
// ✓ CORRECT: Test round-trip with realistic data
test('should serialize and deserialize preserving all data', () {
  final original = WidgetData(
    todayPushups: 50,
    lastWorkoutDate: DateTime(2026, 1, 15),
    calendarDays: List.generate(30, (i) => CalendarDayData(i + 1, i < 5)),
  );

  // Serialize
  final json = original.toJson();

  // Deserialize
  final restored = WidgetData.fromJson(json);

  // Verify ALL fields match
  expect(restored.todayPushups, original.todayPushups);
  expect(restored.lastWorkoutDate?.toIso8601String(),
      original.lastWorkoutDate?.toIso8601String());
  expect(restored.calendarDays.length, original.calendarDays.length);
});

// ✓ CORRECT: Test edge cases
test('should handle empty and null values', () {
  final json = {
    'todayPushups': null,  // Missing field
    'lastWorkoutDate': '',  // Empty string
    'calendarDays': null,  // Null list
  };
  final data = WidgetData.fromJson(json);
  expect(data.todayPushups, 0);  // Default value
  expect(data.lastWorkoutDate, isNull);
  expect(data.calendarDays, isEmpty);
});
```

**Warning signs:** Tests pass but app crashes, "type 'String' is not a subtype of type 'int'" errors, null pointer exceptions in widget.

### Pitfall 5: Cross-Platform Compatibility

**What goes wrong:** App crashes on Windows (development platform) because widgets are Android-only.

**Why it happens:**
- Calling home_widget methods without platform check
- Assuming widget service is always available
- Not testing on development platform (Windows)

**How to avoid:**
```dart
// ✓ CORRECT: Graceful degradation
class WidgetUpdateService {
  bool _isAvailable = false;

  Future<bool> initialize() async {
    try {
      _isAvailable = true; // home_widget handles platform checks
      return _isAvailable;
    } catch (e) {
      _isAvailable = false; // Not Android - widgets unavailable
      return false;
    }
  }

  Future<bool> updateAllWidgets(WidgetData data) async {
    if (!_isAvailable) return false; // Silent fail on Windows
    // ... rest of implementation
  }
}
```

**Warning signs:** App crashes on Windows, "MissingPluginException" errors, developers can't run app on development machine.

### Pitfall 6: Widget ID Mismatch

**What goes wrong:** `HomeWidget.updateWidget()` called but widget doesn't refresh.

**Why it happens:**
- Widget ID in Dart code doesn't match AndroidManifest.xml receiver name
- Using simple name instead of fully qualified class name
- Case sensitivity errors (e.g., "Widget" vs "widget")

**How to avoid:**
```dart
// ✓ CORRECT: Use constants matching Android receiver class names
static const String _widget1Id = 'PushupWidgetStatsProvider';
static const String _widget2Id = 'PushupWidgetCalendarProvider';
static const String _widget3Id = 'PushupWidgetQuickStartProvider';

// Must match AndroidManifest.xml:
// android:name=".widget.PushupWidgetStatsProvider"

await HomeWidget.updateWidget(_widget1Id);
```

**Warning signs:** Widget updates work sometimes but not others, only specific widgets update, errors in Logcat about "widget not found".

## Code Examples

Verified patterns from official sources:

### Saving Widget Data from Flutter

```dart
// Source: https://pub.dev/packages/home_widget

// Save primitive data
await HomeWidget.saveWidgetData<String>('group_id', 'key', 'value');
await HomeWidget.saveWidgetData<int>('group_id', 'count', 42);

// Save JSON string
await HomeWidget.saveWidgetData<String>(
  'pushup_widget_data',
  'widget_data',
  widgetData.toJsonString(),
);

// Trigger widget update
await HomeWidget.updateWidget('PushupWidgetStatsProvider');
```

### Reading Widget Data in Android (Kotlin)

```kotlin
// Source: android/app/src/main/kotlin/.../widget/PushupWidgetStatsProvider.kt

override fun onUpdate(
    context: Context,
    appWidgetManager: AppWidgetManager,
    appWidgetIds: IntArray
) {
    for (appWidgetId in appWidgetIds) {
        updateAppWidget(context, appWidgetManager, appWidgetId)
    }
}

companion object {
    fun updateAppWidget(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetId: Int
    ) {
        val views = RemoteViews(context.packageName, R.layout.pushup_widget_stats)

        // Read data from SharedPreferences
        val prefs = context.getSharedPreferences("pushup_widget_data", Context.MODE_PRIVATE)

        // Get values with defaults
        val todayPushups = prefs.getInt("today_pushups", 0)
        val totalPushups = prefs.getInt("total_pushups", 0)

        // Update views
        views.setTextViewText(R.id.today_count, todayPushups.toString())
        views.setTextViewText(R.id.total_count, "$totalPushups / 5050")

        // Update widget
        appWidgetManager.updateAppWidget(appWidgetId, views)
    }
}
```

### Testing JSON Serialization

```dart
// Source: https://docs.flutter.dev/data-and-backend/serialization/json

test('WidgetData round-trip serialization', () {
  // Arrange
  final original = WidgetData(
    todayPushups: 41,
    totalPushups: 1500,
    goalPushups: 5050,
    todayGoalReached: false,
    streakDays: 3,
    lastWorkoutDate: DateTime(2026, 1, 20),
    calendarDays: [
      CalendarDayData(1, true),
      CalendarDayData(2, true),
      CalendarDayData(3, false),
    ],
  );

  // Act - serialize
  final jsonString = original.toJsonString();

  // Act - deserialize
  final restored = WidgetData.fromJsonString(jsonString);

  // Assert - all fields match
  expect(restored.todayPushups, original.todayPushups);
  expect(restored.totalPushups, original.totalPushups);
  expect(restored.lastWorkoutDate?.toIso8601String(),
      original.lastWorkoutDate?.toIso8601String());
  expect(restored.calendarDays.length, original.calendarDays.length);

  // Verify nested objects
  for (var i = 0; i < original.calendarDays.length; i++) {
    expect(restored.calendarDays[i].day, original.calendarDays[i].day);
    expect(restored.calendarDays[i].completed, original.calendarDays[i].completed);
  }
});
```

### Widget XML Configuration (30-Min Updates)

```xml
<!-- Source: android/app/src/main/res/xml/pushup_widget_stats_info.xml -->

<?xml version="1.0" encoding="utf-8"?>
<appwidget-provider
    xmlns:android="http://schemas.android.com/apk/res/android"

    <!-- Size (4x2 grid cells) -->
    android:minWidth="250dp"
    android:minHeight="110dp"
    android:targetCellWidth="4"
    android:targetCellHeight="2"

    <!-- Updates: 30 minutes = 1800000 ms (minimum allowed) -->
    android:updatePeriodMillis="1800000"

    <!-- Layout -->
    android:initialLayout="@layout/pushup_widget_stats"

    <!-- Resizing -->
    android:resizeMode="horizontal|vertical"

    <!-- Placement -->
    android:widgetCategory="home_screen"

    <!-- Preview -->
    android:previewImage="@drawable/pushup_widget_preview">
</appwidget-provider>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| RemoteViews manual updates | home_widget plugin bridge | 2020+ | Simplified Flutter integration, unified API |
| WorkManager required for all updates | Native updatePeriodMillis sufficient for 30-min+ | 2022+ | Reduced dependencies, simpler implementation |
| json_serializable required | Manual dart:convert acceptable for simple models | 2024+ | Faster builds, less boilerplate for small models |
| Custom IPC for widget data | SharedPreferences bridge (home_widget) | 2021+ | Cross-process safe, standard Android pattern |

**Deprecated/outdated:**
- **AlarmManager for widget updates:** Replaced by WorkManager (for complex tasks) or updatePeriodMillis (for simple periodic updates)
- **Custom ContentProvider for widget data:** Overkill. SharedPreferences is sufficient and simpler
- **Assuming widgets run in app process:** They don't. Always use cross-process data sharing (SharedPreferences)
- **ISO 8601 date strings for widgets:** Too complex. Use simple YYYY-MM-DD format for timezone safety

**Current best practice (2025):**
- Use home_widget plugin for Flutter-native widget integration
- Leverage Android's native updatePeriodMillis for 30-min periodic updates
- Use manual JSON serialization (dart:convert) for simple widget data models
- Implement graceful degradation for non-Android platforms
- Test widget data serialization with round-trip tests

## Open Questions

### 1. Background Update Strategy Refinement

**What we know:**
- Native updatePeriodMillis provides 30-min updates (minimum)
- WorkManager enables more frequent updates but adds complexity
- Current implementation uses placeholder approach (stub method)

**What's unclear:**
- Do we need updates more frequent than 30 minutes?
- Is 30-minute lag acceptable for push-up stats?
- Should updates be triggered by user actions (e.g., after workout)?

**Recommendation:** Start with native 30-min updates. Monitor user feedback. Only add WorkManager if users explicitly request real-time widget updates. For Phase 2.1, implement basic periodic updates using updatePeriodMillis (already configured in XML).

### 2. Widget Update Triggers

**What we know:**
- Widgets should update when app state changes (workout completed, goal reached)
- home_widget.updateWidget() must be called after data changes
- Multiple places in app may trigger updates

**What's unclear:**
- Should we update widgets on EVERY data change or debounce?
- Should we update all 3 widget types simultaneously or individually?
- How to handle update failures (retry or silent fail)?

**Recommendation:**
1. Update all widgets on critical state changes (workout save, goal reached, streak change)
2. Debounce non-critical updates (e.g., don't update on every push-up count, only on series complete)
3. Silent fail is acceptable (widgets are optional feature)
4. For Phase 2.1, call updateAllWidgets() from existing state management providers (UserStats, DailyRecords)

### 3. Test Coverage for Widget Layer

**What we know:**
- widget_data_test.dart exists and tests JSON serialization
- Tests cover round-trip serialization, edge cases, factory methods

**What's unclear:**
- Should we test WidgetUpdateService with mocked home_widget?
- Should we write integration tests for widget updates?
- How to test Android widget provider (Kotlin) from Flutter tests?

**Recommendation:**
- **Phase 2.1:** Unit tests for WidgetData (✅ already done), mock tests for WidgetUpdateService
- **Phase 2.2+:** Integration tests that verify data flow from app → widget
- **Android tests:** Separate Kotlin unit tests for widget providers (outside Flutter test suite)
- **Manual testing:** Required for end-to-end widget verification (cannot automate fully)

## Sources

### Primary (HIGH confidence)
- **home_widget plugin (pub.dev)** - Official package documentation, API reference
- **Flutter JSON Serialization Guide** (docs.flutter.dev) - Official documentation updated 2025-10-30
- **Android App Widgets Guide** (developer.android.com) - Native widget development documentation
- **Dart Testing Guide** (dart.dev) - Official testing best practices updated 2025-09-15

### Secondary (MEDIUM confidence)
- **Building Interactive Android HomeScreen Widgets** (Medium, 2025-11-29) - Step-by-step home_widget integration guide
- **How to Reliably Update Widgets on Android** (Arkadiusz Chmura) - Widget update strategies and patterns
- **Implementing Android Widgets: A Practical Guide** (Medium, 2025) - Common pitfalls and solutions
- **WorkManager in Flutter** (Medium, 2025) - Background task patterns (verified against official docs)

### Tertiary (LOW confidence)
- **Flutter Background Processes** (docs.flutter.dev, 2025-10-30) - Overview of background task options
- **Stack Overflow discussions** - Specific implementation questions, community-verified solutions
- **GitHub issues (home_widget, workmanager)** - Real-world problems and workarounds

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - home_widget is well-established, pub.dev shows active maintenance
- Architecture: HIGH - Patterns verified against official Flutter/Android documentation
- Testing patterns: HIGH - Based on official Dart testing guidelines
- Pitfalls: MEDIUM - Based on common issues reported in GitHub issues and StackOverflow, but some edge cases may be project-specific
- Background update strategy: MEDIUM - Native approach verified, but WorkManager tradeoffs require real-world testing

**Research date:** 2026-01-21
**Valid until:** 2026-02-20 (30 days - stable domain with infrequent breaking changes)

**Current state of project:**
- ✅ home_widget ^0.5.0 added to pubspec.yaml
- ✅ AndroidManifest.xml configured with 3 widget receivers
- ✅ WidgetData model exists with JSON serialization
- ✅ WidgetUpdateService implements update logic
- ✅ Tests exist for widget data serialization
- ✅ Android widget providers implemented (Kotlin)
- ✅ Widget XML configs use 30-min updatePeriodMillis
- ⚠️ Background update mechanism is stub (needs implementation)
- ⚠️ No integration tests for end-to-end widget updates

**Phase 2.1 focus:** Verify existing infrastructure works, implement proper background update mechanism, add missing tests, integrate widget updates into app state management.
