---
phase: 02.1-foundation-setup
plan: 02
type: execute
wave: 2
depends_on: [02.1-01]
files_modified:
  - push_up_5050/lib/providers/user_stats_provider.dart
  - push_up_5050/lib/providers/active_workout_provider.dart
  - push_up_5050/lib/main.dart
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Widgets update when UserStatsProvider data changes"
    - "Widgets update when workout session completes"
    - "Widget updates are triggered automatically, not manually"
    - "WidgetUpdateService is initialized on app startup"
  artifacts:
    - path: "push_up_5050/lib/providers/user_stats_provider.dart"
      provides: "User statistics with automatic widget updates"
      exports: ["UserStatsProvider", "loadStats", "refreshStats"]
    - path: "push_up_5050/lib/providers/active_workout_provider.dart"
      provides: "Workout session management with widget updates"
      exports: ["ActiveWorkoutProvider", "endWorkout"]
    - path: "push_up_5050/lib/main.dart"
      provides: "App entry point with WidgetUpdateService initialization"
      contains: "WidgetUpdateService.*initialize"
  key_links:
    - from: "lib/providers/user_stats_provider.dart"
      to: "lib/services/widget_update_service.dart"
      via: "Calls updateAllWidgets() after loadStats() completes"
      pattern: "_widgetUpdateService\\.updateAllWidgets"
    - from: "lib/providers/active_workout_provider.dart"
      to: "lib/services/widget_update_service.dart"
      via: "Calls updateAllWidgets() after endWorkout() saves daily record"
      pattern: "_widgetUpdateService\\.updateAllWidgets"
    - from: "lib/main.dart"
      to: "lib/services/widget_update_service.dart"
      via: "Initializes WidgetUpdateService on app startup"
      pattern: "WidgetUpdateService.*initialize"
---

# Phase 2.1-02: Integrate Widget Updates into App State

## Objective
Integrate WidgetUpdateService into the app's state management layer so widgets update automatically when data changes.

**Purpose:** Widgets currently have no trigger to update. This plan connects widget updates to the natural data flow: when workout completes or stats refresh, widgets receive fresh data automatically.

**Output:** UserStatsProvider and ActiveWorkoutProvider call WidgetUpdateService on relevant state changes.

## Context
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02.1-foundation-setup/02.1-RESEARCH.md
@.planning/phases/02.1-foundation-setup/02.1-01-SUMMARY.md

# Codebase references
@push_up_5050/lib/providers/user_stats_provider.dart
@push_up_5050/lib/providers/active_workout_provider.dart
@push_up_5050/lib/main.dart
@push_up_5050/lib/services/widget_update_service.dart
@push_up_5050/lib/models/widget_data.dart

## Tasks

### Task 1: Add WidgetUpdateService to UserStatsProvider
**type:** auto
**estimate:** medium

**Action:**
Modify `lib/providers/user_stats_provider.dart` to integrate widget updates.

1. Add WidgetUpdateService dependency:
```dart
import 'package:push_up_5050/services/widget_update_service.dart';
import 'package:push_up_5050/models/widget_data.dart';

class UserStatsProvider extends ChangeNotifier {
  final StorageService _storage;
  final WidgetUpdateService _widgetUpdateService;

  UserStatsProvider({
    required StorageService storage,
    required WidgetUpdateService widgetUpdateService,
  }) : _storage = storage,
       _widgetUpdateService = widgetUpdateService;
```

2. Add widget update trigger at end of `loadStats()` method, after `_isLoading = false`:
```dart
  Future<void> loadStats() async {
    _isLoading = true;
    notifyListeners();

    try {
      // ... existing loadStats code ...

      _isLoading = false;
      notifyListeners();

      // Update widgets with fresh data
      await _updateWidgets();
    } catch (e) {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> _updateWidgets() async {
    // Build WidgetData from current stats
    final calendarDays = last30DaysRecords.asMap().entries.map((entry) {
      final index = entry.key;
      final record = entry.value;
      // Calculate day number from today (index 29 = today)
      final now = DateTime.now();
      final day = now.subtract(Duration(days: 29 - index)).day;
      return CalendarDayData(day, record?.goalReached ?? false);
    }).toList();

    final widgetData = WidgetData(
      todayPushups: _todayPushups,
      totalPushups: _totalPushupsAllTime,
      goalPushups: 5050,
      todayGoalReached: _todayPushups >= 50,
      streakDays: _currentStreak,
      lastWorkoutDate: _allDailyRecords.isNotEmpty
          ? _getLastWorkoutDate()
          : null,
      calendarDays: calendarDays,
    );

    await _widgetUpdateService.updateAllWidgets(widgetData);
  }

  DateTime? _getLastWorkoutDate() {
    if (_allDailyRecords.isEmpty) return null;
    // Find most recent date with a record
    DateTime? latestDate;
    for (final entry in _allDailyRecords.entries) {
      final dateString = entry.key as String;
      final parts = dateString.split('-');
      final date = DateTime(
        int.parse(parts[0]),
        int.parse(parts[1]),
        int.parse(parts[2]),
      );
      if (latestDate == null || date.isAfter(latestDate)) {
        latestDate = date;
      }
    }
    return latestDate;
  }
```

**Why this design:**
- Widget updates happen AFTER stats are loaded and UI is notified
- Silent failure: widget errors don't crash the app
- Calendar data derived from existing last30DaysRecords
- Uses existing computed properties (todayPushups, totalPushupsAllTime, etc.)

**Verification:**
- UserStatsProvider compiles without errors
- Import for WidgetUpdateService and WidgetData exists
- `_updateWidgets()` private method added
- Call to `_updateWidgets()` at end of `loadStats()`

**Done:**
- UserStatsProvider creates WidgetData from its state
- Widgets update whenever loadStats() completes
- Provider signature includes WidgetUpdateService dependency

---

### Task 2: Add WidgetUpdateService to ActiveWorkoutProvider
**type:** auto
**estimate:** medium

**Action:**
Modify `lib/providers/active_workout_provider.dart` to trigger widget updates after workout completion.

1. Add WidgetUpdateService dependency:
```dart
import 'package:push_up_5050/services/widget_update_service.dart';
import 'package:push_up_5050/models/widget_data.dart';
import 'package:push_up_5050/models/calendar_day_data.dart';

class ActiveWorkoutProvider extends ChangeNotifier {
  final StorageService _storage;
  final WidgetUpdateService _widgetUpdateService;

  ActiveWorkoutProvider({
    required StorageService storage,
    required WidgetUpdateService widgetUpdateService,
  }) : _storage = storage,
       _widgetUpdateService = widgetUpdateService;
```

2. Add helper method to build WidgetData after workout:
```dart
  Future<void> _updateWidgetsAfterWorkout() async {
    try {
      // Get today's record for widget data
      final today = DateTime.now();
      final todayRecord = await _storage.getDailyRecord(today);

      // Get all records for calendar and streak
      final allRecords = await _storage.loadDailyRecords();
      int totalPushups = 0;
      for (final entry in allRecords.entries) {
        final recordData = entry.value as Map<String, dynamic>;
        final record = DailyRecord.fromJson(recordData);
        totalPushups += record.totalPushups;
      }

      final streak = await _storage.calculateCurrentStreak();

      // Build calendar days (last 30 days)
      final calendarDays = <CalendarDayData>[];
      final now = DateTime.now();
      for (int i = 29; i >= 0; i--) {
        final date = now.subtract(Duration(days: i));
        final dateKey =
            '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

        final hasRecord = allRecords.containsKey(dateKey);
        calendarDays.add(CalendarDayData(
          date.day,
          hasRecord,
        ));
      }

      final widgetData = WidgetData(
        todayPushups: todayRecord?.totalPushups ?? 0,
        totalPushups: totalPushups,
        goalPushups: 5050,
        todayGoalReached: (todayRecord?.totalPushups ?? 0) >= 50,
        streakDays: streak,
        lastWorkoutDate: today,
        calendarDays: calendarDays,
      );

      await _widgetUpdateService.updateAllWidgets(widgetData);
    } catch (e) {
      // Silently fail - widgets are optional
    }
  }
```

3. Call `_updateWidgetsAfterWorkout()` at end of `endWorkout()`, after daily record is saved:
```dart
  Future<void> endWorkout() async {
    if (_session == null) return;

    // ... existing endWorkout code ...

    if (existingRecord != null) {
      final mergedRecord = DailyRecord(
        date: today,
        totalPushups: existingRecord.totalPushups + record.totalPushups,
        seriesCompleted: existingRecord.seriesCompleted + record.seriesCompleted,
      );
      await _storage.saveDailyRecord(mergedRecord);
    } else {
      await _storage.saveDailyRecord(record);
    }

    // Update widgets with new workout data
    await _updateWidgetsAfterWorkout();

    notifyListeners();
  }
```

**Verification:**
- ActiveWorkoutProvider compiles without errors
- Import for WidgetUpdateService, WidgetData, CalendarDayData exists
- `_updateWidgetsAfterWorkout()` method added
- Call to `_updateWidgetsAfterWorkout()` at end of `endWorkout()`

**Done:**
- ActiveWorkoutProvider updates widgets after workout completion
- Widget data reflects latest workout stats
- Graceful silent failure if widget update fails

---

### Task 3: Initialize WidgetUpdateService in main.dart
**type:** auto
**estimate:** small

**Action:**
Modify `lib/main.dart` to initialize WidgetUpdateService at app startup.

1. Add WidgetUpdateService initialization:
```dart
import 'package:push_up_5050/services/widget_update_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize widget update service
  final widgetUpdateService = WidgetUpdateService();
  await widgetUpdateService.initialize();

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(
          create: (_) => ActiveWorkoutProvider(
            storage: storageService,
            widgetUpdateService: widgetUpdateService,
          ),
        ),
        ChangeNotifierProvider(
          create: (_) => UserStatsProvider(
            storage: storageService,
            widgetUpdateService: widgetUpdateService,
          ),
        ),
        // ... other providers ...
      ],
      child: const PushUpApp(),
    ),
  );
}
```

**Note:** The existing main.dart structure may vary. Adapt the integration to match the current provider setup pattern. Key is to create a single shared WidgetUpdateService instance and pass it to both UserStatsProvider and ActiveWorkoutProvider.

**Verification:**
- main.dart compiles without errors
- WidgetUpdateService import added
- WidgetUpdateService instance created and initialized before runApp
- WidgetUpdateService passed to UserStatsProvider and ActiveWorkoutProvider

**Done:**
- WidgetUpdateService initialized on app startup
- Single shared instance used across providers
- App launches without errors

---

## Verification
After completing all tasks:
- [ ] `flutter analyze` shows no errors in modified files
- [ ] `flutter test` passes all provider tests
- [ ] App compiles and launches successfully
- [ ] WidgetUpdateService is available to both providers

## Success Criteria
- UserStatsProvider triggers widget updates after loading stats
- ActiveWorkoutProvider triggers widget updates after workout completion
- WidgetUpdateService is initialized once and shared between providers
- App runs without errors related to widget service

## Output
After completion, create `.planning/phases/02.1-foundation-setup/02.1-02-SUMMARY.md`
