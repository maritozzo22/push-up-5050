---
phase: 02.1-foundation-setup
plan: 03
type: execute
wave: 3
depends_on: [02.1-02]
files_modified:
  - push_up_5050/integration_test/widget_update_integration_test.dart
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Integration test verifies end-to-end widget data flow"
    - "Widget data serializes and deserializes correctly"
    - "Providers trigger widget updates on state changes"
    - "All tests pass including new integration test"
  artifacts:
    - path: "push_up_5050/integration_test/widget_update_integration_test.dart"
      provides: "End-to-end widget update verification"
      exports: ["main", "Widget Update Integration"]
  key_links:
    - from: "integration_test/widget_update_integration_test.dart"
      to: "lib/providers/user_stats_provider.dart"
      via: "Tests that loadStats() triggers widget update"
      pattern: "provider\\.loadStats"
    - from: "integration_test/widget_update_integration_test.dart"
      to: "lib/services/widget_update_service.dart"
      via: "Verifies WidgetUpdateService is called with correct data"
      pattern: "WidgetUpdateService|updateAllWidgets"
---

# Phase 2.1-03: Add Integration Tests

## Objective
Add integration test that verifies the complete widget update flow from app state changes through to widget data serialization.

**Purpose:** Unit tests verify components in isolation. Integration tests verify the wired-together behavior: when stats load or workout completes, widgets receive updated data.

**Output:** Integration test file with end-to-end widget update verification.

## Context
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02.1-foundation-setup/02.1-RESEARCH.md
@.planning/phases/02.1-foundation-setup/02.1-01-SUMMARY.md
@.planning/phases/02.1-foundation-setup/02.1-02-SUMMARY.md

# Codebase references
@push_up_5050/integration_test/persistence_test.dart
@push_up_5050/lib/services/widget_update_service.dart
@push_up_5050/lib/providers/user_stats_provider.dart
@push_up_5050/lib/providers/active_workout_provider.dart
@push_up_5050/lib/models/widget_data.dart

## Tasks

### Task 1: Create Widget Update Integration Test
**type:** auto
**estimate:** medium

**Action:**
Create `push_up_5050/integration_test/widget_update_integration_test.dart` with the following test structure:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:push_up_5050/main.dart' as app;
import 'package:push_up_5050/models/widget_data.dart';
import 'package:push_up_5050/providers/user_stats_provider.dart';
import 'package:push_up_5050/providers/active_workout_provider.dart';
import 'package:push_up_5050/repositories/storage_service.dart';
import 'package:push_up_5050/services/widget_update_service.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Widget Update Integration', () {
    late StorageService storageService;
    late WidgetUpdateService widgetUpdateService;
    late UserStatsProvider userStatsProvider;
    late ActiveWorkoutProvider activeWorkoutProvider;

    setUp(() async {
      // Initialize services
      storageService = StorageService();
      await storageService.initialize();

      widgetUpdateService = WidgetUpdateService();
      await widgetUpdateService.initialize();

      // Create providers
      userStatsProvider = UserStatsProvider(
        storage: storageService,
        widgetUpdateService: widgetUpdateService,
      );

      activeWorkoutProvider = ActiveWorkoutProvider(
        storage: storageService,
        widgetUpdateService: widgetUpdateService,
      );

      // Clear any existing test data
      await storageService.clearAll();
    });

    tearDown(() async {
      await storageService.clearAll();
    });

    testWidgets('WidgetData serializes and deserializes correctly',
        (tester) async {
      // Arrange
      final originalData = WidgetData(
        todayPushups: 50,
        totalPushups: 1500,
        goalPushups: 5050,
        todayGoalReached: true,
        streakDays: 5,
        lastWorkoutDate: DateTime(2026, 1, 20),
        calendarDays: [
          CalendarDayData(1, true),
          CalendarDayData(2, true),
          CalendarDayData(3, false),
        ],
      );

      // Act
      final jsonString = originalData.toJsonString();
      final restoredData = WidgetData.fromJsonString(jsonString);

      // Assert
      expect(restoredData.todayPushups, originalData.todayPushups);
      expect(restoredData.totalPushups, originalData.totalPushups);
      expect(restoredData.todayGoalReached, originalData.todayGoalReached);
      expect(restoredData.streakDays, originalData.streakDays);
      expect(
        restoredData.lastWorkoutDate?.toIso8601String(),
        originalData.lastWorkoutDate?.toIso8601String(),
      );
      expect(restoredData.calendarDays.length, originalData.calendarDays.length);
    });

    testWidgets('WidgetUpdateService initializes and is available',
        (tester) async {
      // Act
      final isAvailable = widgetUpdateService.isAvailable;

      // Assert
      expect(isAvailable, isTrue);
    });

    testWidgets('WidgetUpdateService handles empty widget data',
        (tester) async {
      // Arrange
      final emptyData = WidgetData.empty();

      // Act & Assert - should not throw
      final result = await widgetUpdateService.updateAllWidgets(emptyData);

      // Result is bool (may be false on Windows, true on Android)
      expect(result, isA<bool>());
    });

    testWidgets('WidgetUpdateService handles complete widget data',
        (tester) async {
      // Arrange
      final completeData = WidgetData(
        todayPushups: 41,
        totalPushups: 500,
        goalPushups: 5050,
        todayGoalReached: false,
        streakDays: 2,
        lastWorkoutDate: DateTime(2026, 1, 20),
        calendarDays: List.generate(
          30,
          (i) => CalendarDayData(i + 1, i < 5),
        ),
      );

      // Act & Assert - should not throw
      final result = await widgetUpdateService.updateAllWidgets(completeData);

      // Result is bool
      expect(result, isA<bool>());
    });

    testWidgets('UserStatsProvider can be created with widget service',
        (tester) async {
      // Assert - provider was created in setUp without throwing
      expect(userStatsProvider, isNotNull);
      expect(userStatsProvider.isLoading, isTrue);
    });

    testWidgets('UserStatsProvider loadStats completes without error',
        (tester) async {
      // Act
      await userStatsProvider.loadStats();

      // Assert
      expect(userStatsProvider.isLoading, isFalse);
      expect(userStatsProvider.todayPushups, greaterThanOrEqualTo(0));
      expect(userStatsProvider.totalPushupsAllTime, greaterThanOrEqualTo(0));
    });

    testWidgets('ActiveWorkoutProvider can be created with widget service',
        (tester) async {
      // Assert - provider was created in setUp without throwing
      expect(activeWorkoutProvider, isNotNull);
      expect(activeWorkoutProvider.session, isNull);
    });

    testWidgets('ActiveWorkoutProvider workout lifecycle works',
        (tester) async {
      // Act - start workout
      await activeWorkoutProvider.startWorkout(
        startingSeries: 1,
        restTime: 30,
      );

      // Assert
      expect(activeWorkoutProvider.session, isNotNull);
      expect(activeWorkoutProvider.session?.startingSeries, 1);

      // Act - end workout
      await activeWorkoutProvider.endWorkout();

      // Assert
      expect(activeWorkoutProvider.session, isNull);
    });

    testWidgets('App launches without errors', (tester) async {
      // Act - launch app
      app.main();
      await tester.pumpAndSettle();

      // Assert - app renders without crashing
      expect(find.byType(app.PushUpApp), findsOneWidget);
    });
  });
}
```

**Note:** If `PushUpApp` is not the main widget class name, adjust the test to use the correct class from main.dart. Use `find.byType(app.MaterialApp)` or `find.byType(app.MyApp)` as appropriate.

**Verification:**
- File exists at integration_test/widget_update_integration_test.dart
- All imports are valid
- Test file compiles without errors

**Done:**
- Integration test file created
- Tests verify widget data serialization
- Tests verify widget service functionality
- Tests verify provider integration

---

### Task 2: Run Integration Tests
**type:** auto
**estimate:** small

**Action:**
Run the new integration test to verify it passes.

**Verification:**
```bash
cd push_up_5050 && flutter test integration_test/widget_update_integration_test.dart
```
Expected: All tests pass. Some tests may show `result = false` on Windows (expected behavior - widgets not available on Windows).

**Done:**
- Integration test passes
- Any failures are investigated and fixed

---

### Task 3: Run Full Test Suite
**type:** auto
**estimate:** small

**Action:**
Run the complete test suite to ensure no regressions from the new integration.

**Verification:**
```bash
cd push_up_5050 && flutter test
```
Expected: All tests pass.

**Done:**
- Full test suite passes
- No regressions introduced
- Test coverage for widget layer is complete

---

## Verification
After completing all tasks:
- [ ] Integration test file created
- [ ] `flutter test integration_test/widget_update_integration_test.dart` passes
- [ ] `flutter test` (full suite) passes
- [ ] Test coverage for widget updates is verified

## Success Criteria
- Integration tests verify end-to-end widget data flow
- Widget data serialization is tested
- Provider integration with widget service is tested
- All existing tests continue to pass
- Test coverage supports Phase 2.2 (Widget 1 implementation)

## Output
After completion, create `.planning/phases/02.1-foundation-setup/02.1-03-SUMMARY.md`
